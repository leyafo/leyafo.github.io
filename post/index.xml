<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Doing Right Things</title>
    <link>http://www.leyafo.com/post/</link>
    <description>Recent content in Posts on Doing Right Things</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 13 Jul 2016 02:51:00 +0800</lastBuildDate>
    <atom:link href="http://www.leyafo.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>开发笔记(1) － Count 问题 </title>
      <link>http://www.leyafo.com/post/2016-07-13-development-notes-1-count-problems/</link>
      <pubDate>Wed, 13 Jul 2016 02:51:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2016-07-13-development-notes-1-count-problems/</guid>
      <description>&lt;p&gt;我们现在的生产环境里面最大的表数据量大概是 1kw 左右。我们这里有一个页面是将这张表里面的数据以列表的方式呈现出来。这个列表的功能有：上一页/下一页、跳页、总数页、数据的总条目数。这是一个很常见的 web 列表拥有的功能，这一系列的功能在数据量 10w 以下工作得很好。超过 10w 后页面 load 就会变得很慢。慢的主要原因是每次刷新操作和跳页操作都会去 Count 整个表，而且是精确的 Count，算法的复杂度为 O(n)。这种方式对于经常需要使用列表页查看数据的用户是完全不可接受的。&lt;/p&gt;

&lt;p&gt;我们开始着手优化这个问题。羊毛出在羊身上，我们用的是 Postgresql 的数据库，当然会想到使用 Postgres 的一些功能去做这个事情。很快我们在 Google 搜索到了 Postgresql 的 &lt;a href=&#34;https://wiki.postgresql.org/wiki/Count_estimate&#34;&gt;Count estimate&lt;/a&gt; 机制。它通过获取 pg_class 这张元表纪录的信息来得到一个表里面大致的数据量。这种方法非常快，速度可达到毫秒级。但它有以下缺点：1.无法精确统计（从 estimate 这个词的意思就能看出来） 2.只能获取整张表的大致数量，无法做 where 条件过滤。问题到这里似乎还是没有解决。&lt;/p&gt;

&lt;p&gt;从程序开发的角度来看，这个问题最好的解决方式是使用一个变量用来保存表的 Count，每次插入删除时需要对这个 Count 变量进行 +1/-1 操作。这样每次需要获取的 Count 时算法复杂度就会降到 O(1)，但从整体上看这个问题其实根本没有得到解决。数据库里面一张大表在做 Insert/Remove 时本身已经很慢了，维护这个 Count 变量需要保证原子操作。这么做不仅非常麻烦，还会增加 Insert/Remove 的开销。&lt;a href=&#34;http://www.varlena.com/GeneralBits/120.php&#34;&gt;这里是具体的做法&lt;/a&gt;。事情到这里已经很明显了，对于数据库精确的 Count，我们是没有办法开发出一种低于 O(n) 复杂度的算法。但这个问题真的无解了吗？&lt;/p&gt;

&lt;p&gt;现在的问题焦点全部都集中在 Count 上面，这个问题看起来是只要 Count 的性能快了，就能解决这个问题。但上面已经说，我们是无法开发出低于 O(n) 复杂度的 Count 算法。1kw 的数据量 O(n) 是无论如何也快不到哪里去的。跳出这个点来看，我们最终要解决的问题是什么？这个 count 的精确数字对用户来说真的能重要到牺牲等待时间来获取吗？其实在这个功能里面我们只所以需要 Count 这个数字仅仅是在做分页时精确需要计算出有多少页，尾页的数字是多少。所以影响这个问题的关键根本不是用户的需求，而是我们在程序开发时所追求的精确。只需要把这个 count 数字去掉就可以了，这将会让列表的操作速度大大的提升。实际上搜索引擎就是这么干的。以 Google 搜索为例，我们在搜索引擎随便输入点东西进行搜索得到得结果是海量的，它只会告诉你“大约”得到多少个结果，结果页展示一页，你并不会知道尾页在哪里（也不需要知道）。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于测试</title>
      <link>http://www.leyafo.com/post/2016-05-16-about-test/</link>
      <pubDate>Mon, 16 May 2016 00:25:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2016-05-16-about-test/</guid>
      <description>&lt;p&gt;在我做 C/C++ 开发时测试这个概念在这个圈子里不那么流行，这也有可能是 C/C++ 这类静态语言写 test 不是那么好写。 C/C++ 这类静态语言写 test code 光想一想也挺烦的。但这并不是因此就不写测试一个借口。我现在做的 Rails 项目一开始也认为写测试会拖慢项目进度的，后来实践下来发现测试能很好的维护项目的稳定，这实际上节约了不少时间。只要克服下一开始认为测试代码会增加的心智负担就好了。&lt;/p&gt;

&lt;p&gt;我们也不必太需要去理会什么 TDD，BDD，DDD 等一类名词。这一类名词对写测试的帮助并不大，而且有害。把原来本来很简单的事情弄得很复杂。写测试关键是要简单，只有简单的测试代码才能测试简单的测试代码。恩，这个有点绕。意思就是代码必须要容易测试，不容易测试的代码要把它改成容易测试的代码。TDD 奉行的测试驱动开发在我看来是挺难做到的。因为有时候我自己都不知道这个代码写好后会变成什么样子。单纯的一个输入输出是很难决定代码中间所经历的一些过程。还有一个重要的点就是被测试代码粒度越小越好，越小意味着模块化程度越高，接口的定义也越干净，这是非常值得的。所以别管什么 BDD, TDD, DDD 这一类名词，尽管写测试代码好了，尽可能把测试覆盖面辐射到更广才是最重要的。&lt;/p&gt;

&lt;p&gt;Rspec 的问题
Rspec 定义了测试的领域语言，他的目的是让非开发人员也能写测试。这个目的挺美好的，想想也挺美好的。实际上我们在项目中很难找到一个会去写测试的测试工程师。写 Rspec 这个东西没有一点开发能力还真搞不定。所以 Rspec 的让非开发人员写 test code 还是想想就好了，test code 还是得你自己来写，因为你对你自己写得模块是最清楚的。另外相对于 Rails 自带的测试框架 Rspec 解决的还是相同的问题。Rails 自带的测试框架已经挺好的了，模块化分析测试也很好的控制了测试的粒度。关键是它非常快，跑完所有的测试要同样数量的 Rspec 快很多。这很重要，Rspec 的性能很为人诟病，因为会增加对写 test code 的厌恶。一个简单的测试用例要跑 10 秒是很影响写代码的体验的。&lt;/p&gt;

&lt;p&gt;测试的作用
改代码比写新的代码要烦，需要小心的应对以前的历史包袱，还要了解以前的工作机制是怎样的。所以，如果有一些现成的测试用例代码就能很好的应对这些问题。它能保证你不回对以前的代码产生副作用，并且在些测试代码阶段可以让你自己在代码层面对接口的合理性做更详细的检查。能让代码质量变得更高。在项目部署前跑一遍所有的测试用例可安心不少，尽管部署时出现的问题大多数集中在恶劣的服务器环境上。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>彻底理解 KMP算法</title>
      <link>http://www.leyafo.com/post/2014-11-14-a-thorough-understanding-of-kmp/</link>
      <pubDate>Fri, 14 Nov 2014 07:02:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2014-11-14-a-thorough-understanding-of-kmp/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm&#34;&gt;KMP&lt;/a&gt; 算法是一种子串匹配算法。其特点在于匹配子串时&lt;strong&gt;利用已经匹配成功的部分子串来跳转到下一次能再次匹配的串&lt;/strong&gt;。书上列举的一大堆公式看着很犯晕，网上各类码农博客里面用代码写的文章，让本来逻辑有点绕的 kmp 更加绕。就我最近看到的文章来说最清晰的就是&lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html&#34;&gt;阮一峰&lt;/a&gt; 和 &lt;a href=&#34;http://www.cnblogs.com/yjiyjige/p/3263858.html&#34;&gt;详解KMP算法&lt;/a&gt;。这两辆篇文章解释的通俗易懂，也有一些不太明晰的地方。本文的目的是在于解释笔者本人在理解 kmp，及阅读这些资料时不明白的地方。
首先还是来看 kmp 匹配子串所使用的方法，下文中字符串“TEST ABCABCABCDEF” 表示要匹配的主串，字符串 &amp;ldquo;ABCABCDEF&amp;rdquo; 表示待匹配的子串。(用肉眼我们可以看到要匹配的子串的位置在最后的位置)。首先像暴力匹配一样我们把不匹配的字符串全部进行匹配并跳过。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;   TEST ABCABCABCDEF
     ABCABCDEF
   |
   |-------- 进入下一个位置进行匹配 ------&amp;gt;  TEST ABCABCABCDEF
                                          ABCABCDEF
                                          |
          &amp;lt;----- 还是不匹配,继续往前走 ------|
          |
          |
          ......前面三个还是不匹配.....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候我们待匹配的子串走到了‘TEST ’后面一个位置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;         TEST ABCABCABCDEF
              ABCABCDEF
                    |
                    |------ D 和 A 不匹配。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候主串和子串出现了部分匹配的情况，这个时候我们的子串该如何前进继续匹配？目前能想到的方法就是按照暴力匹配的方式继续向前进一步。但本文的目的不在于讨论暴力匹配，所以这种方法被 Pass 掉。如果直接将子串移动到现在不匹配 D 的位置，这种方式会错过&lt;strong&gt;可能会匹配的子串&lt;/strong&gt;。比如下面这种情况会错过&lt;strong&gt;可能会匹配的子串&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;       ABCABCDEFGHIJK        -----&amp;gt;     ABCABCDEFG
       ABCDEFG                                ABCDEFG
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此上面的移动是不合法的，算法会出现错误。从这里我们可以观察到合法的移动是将子串移动到 ABC 。这样我们就能再次匹配到 ABC，这也就是本文前面说的那句话，&lt;strong&gt;利用已经匹配成功的部分子串来跳转到下一次能再次匹配的串&lt;/strong&gt;。现在问题是我们该如何在程序中得到这个正确的移动位置？首先我们先来观察已经匹配的部分匹配子串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;         TEST ABCABCABCDEF 
              ABCABCDEF
                    |
                    |---------&amp;gt;部分匹配子串 ABCABC
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从这里我们可以看到 ABC 出现了两次，因此 ABC 是我们需要的&lt;strong&gt;再次匹配的串&lt;/strong&gt;。但这个 ABC 是如何得到的？因此我们现在我们需要解决的问题有2个。
1. 找到&lt;strong&gt;再次匹配串&lt;/strong&gt;。
2. 确定这个&lt;strong&gt;再次匹配串&lt;/strong&gt;需要移动的位置。&lt;/p&gt;

&lt;p&gt;这个时候我们要解决的问题跟主串已经没啥关系了，我们的问题变成了找子串中&lt;strong&gt;重合&lt;/strong&gt;的子串。实际上还是找子串，不同的是这次我需要去&lt;strong&gt;分析部分匹配串里面的子串&lt;/strong&gt;。这个问题比较好解决，我们只需要把&lt;strong&gt;部分匹配串&lt;/strong&gt;全部分解为子串。就能找到出现两次或者两次以上的子串了。因此&lt;em&gt;ABCABC&lt;/em&gt; 可以分解为如下子串：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;BCABC
CABC
ABC
BC
C
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是从后面开始分解的子串，这并没有归纳出所有的子串，还需要从前面开始分解。所以还可以从前面分解如下子串：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ABCAB
ABCA
ABC
AB
A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是&lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html&#34;&gt;阮一峰&lt;/a&gt;的 blog 中所说的前缀和后缀。引入前缀和后缀的目的是为了找到出现两次以上的子串。现在我们的第一个问题 &lt;strong&gt;找到再次匹配的串&lt;/strong&gt;已经解决了，相匹配的子串是‘ABC’。接下来解决第二个问题&lt;strong&gt;确定再次匹配串需要移动的位置&lt;/strong&gt;。这个问题看起来有点难，我们可以引入一些已知的条件来得到这个问题的解。&lt;br /&gt;
已知条件：
1.部分匹配串的长度
2.出现两次以上子串长度
从上面的前缀和后缀我们可以知道，只需要把相同后缀移动到最前面就能和前缀匹配。因此可以得到下面的公式：
要移动的位置 = 部分匹配的长度 - 出现2次以上的后缀长度。
因此我们最后的结果要移动的结果为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;         TEST ABCABCABCDEF 
                 ABCABCDEF
                       |
                       |---------&amp;gt;移动位 6 - len(&#39;abc&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;kmp 会把这些部分匹配的子串信息存到一个 next 数组里面。&lt;em&gt;ABCABCDEF&lt;/em&gt; 对应的 next 的数组如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;
                   ABCABCDEF
index         ---&amp;gt; 012345678
next          ---&amp;gt; 000123000
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>理解红黑树</title>
      <link>http://www.leyafo.com/post/2014-10-27-a-red-black-tree-implementation/</link>
      <pubDate>Mon, 27 Oct 2014 11:27:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2014-10-27-a-red-black-tree-implementation/</guid>
      <description>

&lt;p&gt;红黑树是有序平衡 BST(binary search tree) 的一种，它于1978年由 Guibas 和 Sedgewick 发明。红黑树是&lt;a href=&#34;http://en.wikipedia.org/wiki/2%E2%80%933%E2%80%934_tree&#34;&gt;2-3-4 树&lt;/a&gt; 的一种抽象表示。有趣的是现在大多数算法书关于红黑树都没有提到过 2-3-4 树。算法书上关于红黑树的讲解都是基于定理来实现红黑树。至于这些定理怎么来的，算法书却没有描述过。这就是为啥算法书上的红黑树难以理解，这是算法书的坑。所以要理解红黑树，理解 2-3-4树 是必不可少的一个过程。&lt;/p&gt;

&lt;h2 id=&#34;2-3-4树&#34;&gt;2-3-4树&lt;/h2&gt;

&lt;h3 id=&#34;2-3-4树的基本性质&#34;&gt;2-3-4树的基本性质&lt;/h3&gt;

&lt;p&gt;2-3-4树也是一种有序的平衡树，所有从 leaf 到 root 的 path 的高度都是相等的。每个节点可以容纳1到3个节点，可以有2到4个子节点。下面就是 2-3-4 树的3种类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;         B               D   F                H   K   O  
        / \             /  |  \              / \ / \ / \  
       A   C           B   E   G            A   I   L   Y  
        2树                3树                    4树
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似于 BST，2-3-4对元素的排序是左小右大。不同的3树和4树的子节点会有中间大小的子节点。比如上图的3树中的 E 就比 D 大 比 F 小。4树中的 I 比 H 大，比 K 小。L 比 K 大，比 O 小。&lt;/p&gt;

&lt;h3 id=&#34;2-3-4树的插入&#34;&gt;2-3-4树的插入&lt;/h3&gt;

&lt;p&gt;前面说了 2-3-4树是一种平横树，所有从 leaf 到 root 的 path 的高度都是相等的。这也就意味着每当插入一个新节点不能单纯的像 BST 那样将新的节点插入到树的底部，否则会破坏树的平衡。2-3-4树使用的平衡方法是合并。就是将2树变为3树，3树变4树。如下图：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;          B                         B
         / \        插入 D =&amp;gt;       / \
        A   C                     A  C D  
                                      
         B                            B
        / \          插入 H=&amp;gt;        /   \
       A  C D                      A   C D H
       
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的插入方法解决了往 2-3-4树 插入新节点而不破坏树的平衡的问题。但是如果要插入的节点已经是一个4树了，这种方法就不管用了，因为4树是没法变为5树的。可以将4树往上挪一个节点，并分裂出俩个2树的子节点。如果上面的父节点已经是4树了，则继续往上挪动。直到 root 节点，再需要分裂的话，这个时候可以将 root 节点也进行分裂。root 节点分裂后整颗树的高度会增加一层。如下图所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;        A                  A S                      A   E   S          
       / \     插入 S=&amp;gt;    / | \         =&amp;gt;插入 E   / \ / \ / \    =&amp;gt; 插入 R ----&amp;gt;
       
      先将 A E S 往上分裂  =&amp;gt;      E                                E
                                /  \          插入 R=&amp;gt;           /  \
                               A    S                          A   R S
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-4树的删除&#34;&gt;2-3-4树的删除&lt;/h3&gt;

&lt;p&gt;树结构的删除都很麻烦，2-3-4树 也不例外。2-3-4树 插入的时候需要保持树的平衡，删除的时候也需要保持树的平衡。如果需要降低树的高度从 root 合并来降低树的高度。2-3-4树 和 BST 一样会选择从 leaf 节点将 node 删除。如果找到的节点不是 leaf 节点会从当前节点的右边出发，找到最左边的 leaf 节点来替换，然后删除被替换后的 leaf 节点。如果 leaf 节点是3树或者或者4树，直接删除即可。如果是2树的话就不能直接删除，需要对其进行旋转操作，从临近的同一层节点挪个节点过来补上。如果临近元素也是2树则从父节点挪一个节点下来。
下图是删除3树和4树的情况：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;            C                   C                    D                  D
           /     删除 B=&amp;gt;       /                    /       删除 B =&amp;gt;   /
          AB                  A                    ABC                 AC
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下图是一个比较复杂的删除操作，删除一个非叶子节点，会碰到2树的删除并需要旋转的情况。(节点比较多所以用数字来表示节点)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;                  40
             /         \
           20           50                     删除根节点40
          /  \       /     \                   找到右树最左边的42节点 -----------&amp;gt;
        14   32     43     62 70 79            并替换掉,再删除替换后的叶子节点
        /\   /\     /\     / |  | \
      10 18 25 33  42 47  57 65 74 81
      
                    42
               /         \                       
            左树不变        50                    
                         /    \                  相邻节点也是2树，将43挪下来并合并 ------&amp;gt;
                      43     62 70 79            
                     / \     / |  | \             
                    x  47   57 65 74 81
                    
                    
                    42
                 /      \
             左树不变      50
                        /    \ 
                     43 47  62 70 79           上一步中43也是2树
                            / |  | \           需要从临近的节点通过旋转来拿到一个节点  -----&amp;gt;
                          57 65  74 81
                          
        
                        42
                     /      \
                 左树不变      62             &amp;lt;----- 62旋转上来
                            /    \ 
                          50     70 79
                        /   \    / |  \
                     43 47  57  65 74 81      &amp;lt;----------- 57变为50的子节点
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;红黑树&#34;&gt;红黑树&lt;/h2&gt;

&lt;p&gt;红黑树是2-3-4树的一种抽象表示，在1978年 Guibas 和 Sedgewick 发明最初的红黑树。2008年 Sedgewick 对其进行了改进，并将此命名为 LLRBT(Left-leaning red–black tree 左倾红黑树)。LLRBT 相比1978年的红黑树要简单很多，实现的代码量也少很多。Sedgewick的一篇 &lt;a href=&#34;http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf&#34;&gt;PPT&lt;/a&gt; 对此有非常详细的介绍。 现在大部分工程中的红黑树都是基于1978发明的算法，本文介绍的是 LLRBT。&lt;/p&gt;

&lt;h3 id=&#34;红黑树的抽象表示&#34;&gt;红黑树的抽象表示&lt;/h3&gt;

&lt;p&gt;在红黑树中表示2-3-4树的3树和4树会用红链接来表示。如下图所示(markdown 没有文本色彩支持，本文用//或\\来表示红色链接)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;      A B                   B             A             A B C                     B
     / | \  &amp;lt;=红黑树表示=&amp;gt;  //    或者 =&amp;gt;    \\          / | | \    &amp;lt;=红黑树表示=&amp;gt;  //  \\
                         A                  B                                  A      C
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;红黑树的插入&#34;&gt;红黑树的插入&lt;/h3&gt;

&lt;p&gt;红黑树在插入时也通过旋转来降低或者升高树的高度(关于旋转请看我的&lt;a href=&#34;http://leyafo.logdown.com/posts/178297-avl-tree-implementation&#34;&gt;另一篇文章&lt;/a&gt;)。不同的是红黑树插入节点的方式是按照2-3-4树插入节点的方式来进行的。2-3-4树每插入一个节点会对树自底向上进行调整(合并或分裂)，红黑树也是对应于2-3-4树进行同样的操作。2-3-4树通过将3树合并为4树，4树分裂为俩个2树。红黑树通过旋转来做这些操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;   在2树中插入一个节点：
     D  插入C=&amp;gt;    D
                 //
                C                                                         
                                                   &amp;lt;===等同于3树===&amp;gt;    C D
                   C                       D                          / | \
     C 插入D=&amp;gt;       \\          左旋=&amp;gt;   //
                      D                C
                     
    
    在3树中插入一个节点:  
    
     C H                    H             H 
    / | \      红黑树表示=&amp;gt; //            //             C                         A C H
                         C   插入 A=&amp;gt;   C      右旋=&amp;gt;  // \\       2-3-4树表示=&amp;gt;   / | | \
                                      //             A    H
                                     A

                         H              H              H           
    A H     红黑树表示=&amp;gt; //             //             //             C                  A C H
   / | \              A    插入 C=&amp;gt;    A    左旋=&amp;gt;    A     右旋=&amp;gt;  // \\  2-3-4树表示=&amp;gt; / | | \
                                       \\          //            A    H              
                                         C        C          


    A C                    C             C
   / | \      红黑树表示=&amp;gt; //            // \\                                A C H
                        A   插入 H=&amp;gt;   A     H               2-3-4树表示=&amp;gt;   / | | \
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上图可以看出，LLRBT 之所以使用左倾(left-leaning)是为了将3树限制为一种，以便更容易的将3树转为4树，来减少实现上复杂度。下图是4节点的分裂。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;
                                                         /                  //
      A C H     4树分裂为俩个2树=&amp;gt;  C                      C                 C
     / | | \                     / \      红黑树表示=&amp;gt;  // \\      分裂=&amp;gt;   / \     &amp;lt;---将红链提上去
                                A   H                 A    H             A  H  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;红黑树在最初插入时使用的方式和普通的二叉树一样，递归查找到树的底部，然后将新节点插入到树的底部。在递归往回弹的时候对整颗树进行旋转调整，和2-3-4树使用相同的方式（3树变4树，4树分裂成俩个2树）来调整整颗树的高度。&lt;/p&gt;

&lt;h3 id=&#34;红黑树的删除&#34;&gt;红黑树的删除&lt;/h3&gt;

&lt;p&gt;红黑树的删除方法非常复杂。删除任意一个节点，红黑树会像 BST 一样会从右树的最左边找到一个节点进行替换并删除。所以实现红黑树的关键一点就是要实现 DeleteMin 方法。LLRBT  结构是没有 parent 节点的，在删除一个节点是并不能像 AVL 树那样在删除后再旋转。 LLRBT 在查找要删除的节点时就会对树进行调整，它会将要删除节点的那个方向的树通过旋转将树的高度升高一层。&lt;br /&gt;
下图是在 DeleteMin 方法中将树的左边升高一层&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;          //       &amp;lt;----因为树是向左边递归的，           /
         H              所以到 H 的链都是红的           H
        / \                                        // \\
       C   S          颜色反转，将红色向下传=&amp;gt;        C    S     
      /                                          /
     B                                          B

    这时如果 S 节点的left为红色，需要对其再做两次旋转
           /                          /                        /
          H                          H                        P
        // \\                      // \\                    // \\
       C    S       右旋S=&amp;gt;        C    P         左旋 H=&amp;gt;   H    S      
      /    //                    /      \\                //  
     B    P                     B         S              C
                                                        /
                                                       B
     
                                                      //
            再将颜色反转回来=&amp;gt;                          P
                                                    / \
                                                   H   S
                                                 //
                                                C
                                               /
                                              B                                               
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面做的这些操作的最终目的就是将树的最底部要删除的节点变为红色，这样是为了在删除的时候避免要删除的节点为2树。因为删除3树中的一个节点是不需要做其他转换可以直接删除的。在删除后需要重新自底向上修复整颗树的平衡。这样的删除方式看起来非常慢，实际上确实&lt;a href=&#34;http://www.read.seas.harvard.edu/~kohler/notes/llrb.html&#34;&gt;非常慢&lt;/a&gt;。即使在没有找到要删除的节点也会递归进行旋转-修复这一过程。另外这里的删除使用的抽象方式并不是2-3-4树的删除方式，实际上使用的是2-3树的抽象方式。在红树向下传递的过程中最终的叶子会是颗3树，而不会是4树。Sedgewick 的 PPT 里面并没有说到这个问题。他的&lt;a href=&#34;http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf&#34;&gt;另一篇论文&lt;/a&gt;才说到了这个问题。&lt;/p&gt;

&lt;p&gt;PS：
本人实现的 &lt;a href=&#34;https://github.com/leyafo/practice-algorithm/blob/master/DataStruct/rb_tree.c&#34;&gt;Red Black Tree&lt;/a&gt;。
Sedgewick 的 &lt;a href=&#34;http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf&#34;&gt;PPT&lt;/a&gt; 里面有两个错误.
    1. 在 deleteMax方法中向下递归是 deleteMax(h.left) 应该是 deleteMax(h.right)。
    2. 在 delete 方法中需要添加当前节点是否为空的判断，否则递归到空节点时程序会挂掉。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rails 注册登录</title>
      <link>http://www.leyafo.com/post/2014-07-24-rails-log/</link>
      <pubDate>Thu, 24 Jul 2014 08:53:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2014-07-24-rails-log/</guid>
      <description>

&lt;p&gt;这几天在做一个小型的论坛，做到了注册登录这一块。之前没有完整做过注册登录这个东西，这次我打算从头写到尾去详细的了解里面的一些基本原理。所以这次并没有使用&lt;a href=&#34;https://github.com/plataformatec/devise&#34;&gt;devise&lt;/a&gt;这样的 *gem*。&lt;/p&gt;

&lt;h2 id=&#34;密码存储&#34;&gt;密码存储&lt;/h2&gt;

&lt;p&gt;用户密码安全存储是作为一个 &lt;em&gt;web&lt;/em&gt; 开发者的基本节操。好在现有的一些解决方案已经能比较好的解决这个问题了，做起来也比较容易。只需要了解一些基本的安全常识就可以保证90%的情况下是安全的。
在数据库里面存储加密后的密文是为了防止被拖库，如果黑客拖下了整个用户表，加密后的密码他们拿着也是没有用的。即使是网站的管理员也是没法知道这个密码的真实原文。因为现在一般的密码 &lt;em&gt;hash&lt;/em&gt; 算法是不可逆的。所以现在的一些比较常用的密码明文获取方式是进行&lt;a href=&#34;http://blog.jobbole.com/61872/&#34;&gt;字典暴力破解&lt;/a&gt;。如果在密码原文 &lt;em&gt;hash&lt;/em&gt; 前给密码添加一些比较长的唯一的随机字符串，这会使攻击者的字典基本上失效(因为很长，枚举次数要上升很大一个数量级)。这就是密码加盐(salt)的基本作用。当然加盐的另外一个作用是让两个相同的密码产生不同的 &lt;em&gt;hash&lt;/em&gt; 值。这样即使知道加密算法和加密后的密文也无法通过比较密文来得到原文。
在用户登录时我们会拿到用户的原始密码，这个原始密码相当于一把&lt;strong&gt;钥匙&lt;/strong&gt;。拿着这个密码通过加密算法和数据库里面的 &lt;em&gt;salt&lt;/em&gt;  得到加密后的密文。再用这串密文与数据库的密文进行比对，比对成功后则验证通过。在这样一个过程中，密码看起来就像打开箱子的钥匙一样，由用户携带，网站不进行存储。&lt;/p&gt;

&lt;h2 id=&#34;session-和-cookie&#34;&gt;session 和 cookie&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;cookie&lt;/em&gt; 是存储在用户浏览器中的一段唯一标识，&lt;em&gt;http request&lt;/em&gt; 会将它传送到服务端。现在一般的 &lt;em&gt;web framework&lt;/em&gt; 会去检测用户的 &lt;em&gt;http request&lt;/em&gt; 是否带有 &lt;em&gt;cookie&lt;/em&gt;, 如果没有发现请求中没有 *cookie*，它会建立一个*session*。并且以 &lt;em&gt;cookie&lt;/em&gt; 作为 &lt;em&gt;key&lt;/em&gt; 来保存 *session*。这样如果用户下次同样 &lt;em&gt;cookie&lt;/em&gt; 的 &lt;em&gt;http request&lt;/em&gt; 进来了，就可以找到相同的 *session*。
&lt;em&gt;session&lt;/em&gt; 和 &lt;em&gt;cookie&lt;/em&gt; 是实现记住用户的基石。&lt;em&gt;http&lt;/em&gt; 协议是无状态的协议。在用户登录某一个网站后，我们是需要记住登录状态的。这时候就要通过 &lt;em&gt;cookie&lt;/em&gt; 和 &lt;em&gt;session&lt;/em&gt; 来干这件事情。 &lt;em&gt;rails&lt;/em&gt; 默认是已经将 &lt;em&gt;session&lt;/em&gt; 建立好了。在 &lt;em&gt;controller&lt;/em&gt; 中可以很方便的拿到 &lt;em&gt;session&lt;/em&gt; 变量去存储一些信息。另外比较有意思的是 &lt;em&gt;rails&lt;/em&gt; 默认是将 &lt;em&gt;session&lt;/em&gt; 经过加密后存储在用户 &lt;em&gt;cookie&lt;/em&gt; 中的。当用户的 &lt;em&gt;cookie&lt;/em&gt; 传送到后端时会将 &lt;em&gt;cookie&lt;/em&gt; 进行解密得到相应的 *session*。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Capistrano 部署</title>
      <link>http://www.leyafo.com/post/2014-06-19-capistrano-deployment/</link>
      <pubDate>Thu, 19 Jun 2014 03:07:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2014-06-19-capistrano-deployment/</guid>
      <description>

&lt;p&gt;这几天要部署自己做的一个小板凳，是用 sinatra 写的一个简单的 blog 程序。这个程序很简单，代码非常少，可以像 php 那样直接使用 async 将代码。但我想熟悉下 Ruby 关于部署方面的技术，因此找到了 Capistrano 这个东西。Rails 的 web 后台对环境非常挑剔，Capistrano 是 Ruby 写的， 虽然它可以部署各种语言的代码，但可以部署 Rails 的程序不会太简单。&lt;/p&gt;

&lt;h2 id=&#34;配置项含义&#34;&gt;配置项含义&lt;/h2&gt;

&lt;p&gt;Capistrano 这个东西产生的一大堆配置文件有点让人迷糊。Capfile 相当于一个 makefile 文件，里面设置了一些任务是如何运行的。config目录下有三个配置文件，其中 deploy 子目录是用于配置部署不同的环境。默认的是 production 和 staging 环境配置项分别对应两个同名的文件。deploy.rb 这个文件相当于一个总配置文件，里面的是一些公共的配置项。&lt;br /&gt;
  Capistrano 非常依赖版本控制，在 deploy.rb 文件中 repo_url 是用于设置代码仓库的地址的，配置好这个参数后需要确认服务器有访问代码仓库的权限。 scm 是设置具体的版本控制软件的。Capistrano 支持最好的是 git 和 svn。 deploy_to 是一个非常重要的参数，它指示了代码上传到服务器的具体位置,另外需要确保这个目录与配置好的用户名有足够的访问权限。这几个参数设置好后，其他的参数可以使用默认的了。然后再配置对应环境的具体配置项。
  在环境配置项中，role 参数指示的三项分别是 app，web 和 db。这个三项分开的好处是可以让他们部署到不同的服务器上做负载均衡。单台服务器不用太关心，三项指向同一个地址即可。然后配置服务器的访问权限，配置非常简单，设置好用户名和 ssh public key就可以了。到这里基本的配置已经完成了，运行cap deploy:check 可以检测配置是否成功。这个时候如果 check 成功的话使用 cap deploy 命令就可以成功上传代码了。&lt;/p&gt;

&lt;h2 id=&#34;让代码运行&#34;&gt;让代码运行&lt;/h2&gt;

&lt;p&gt;代码上传后部署的任务已经完成了一小部分了，接下来就是具体的程序的启动与 http request的转发了。我使用的是 nginx + unicorn 组合来干这件事情的。首先要确保代码在本地能正常的运行起来，然后再去服务器上做进一步的测试。实际上更好的方式是所有的软件在本地的机器上能完全正常运行后，再将同样的配置文件上传至服务器。能避免不少因为不同机器，不同环境而引起的问题。这样服务器只负责运行软件，不做任何测试。这也是我最近所理解的生产环境。
首先来配置 unicorn 这个东西，一般的 web framework 都会自带 http 服务器用来做测试。自带的 http 服务器是不推荐直接跑在生产环境下的。nginx 更适合干这种事情，但 nginx 干的事情更加单一，它只负责将请求接收并转发。并不负责应用层的事情。unicorn就是这个应用层（php对应的是fastcgi），他负责将代码运行起来并与nginx进行通信。unicorn配置起来也非常的简单，在config.ru中配置好程序的入口点和unicorn.rb中配置好程序的pid，sock 和 log 文件路径。其中 pid 文件是用于启动与停止后台运行的 unicorn。sock 文件用于和 nginx 进行通信。
现在可以配置 nginx 了，nginx 的配置非常简单。只要设置好 nginx 的 upstream 项，在此项里面设置好 unicorn sock 的具体路径，就可以顺利通过 nginx 访问到unicorn了。&lt;/p&gt;

&lt;h2 id=&#34;capistrano-的-task&#34;&gt;Capistrano 的 task&lt;/h2&gt;

&lt;p&gt;nginx 与 unicorn 部署好后，就可以借助 Capistrano 的 task 来进行一些必要的代码部署步奏。比如重启 http 服务器，更新数据库等一系列事情。这些事情使用 Capistrano 来完成的好处是，task写好好每次部署只需要一条命令就可以自动化完成一些繁琐的事情。这个才是 Capistrano 最核心要解决的问题。
这里拿 unicorn 的重启为例来展示如何在远端服务器执行一些 shell 命令。unicorn 网上有一个控制它停止与重新启动的 &lt;a href=&#34;https://www.google.com/search?q=unicorn&amp;amp;oq=unicorn&amp;amp;aqs=chrome..69i57j69i59l3j69i60l2.926j0j1&amp;amp;sourceid=chrome&amp;amp;es_sm=119&amp;amp;ie=UTF-8#newwindow=1&amp;amp;q=unicorn_init&amp;amp;safe=off&#34;&gt;shell&lt;/a&gt; 脚本。下面是一个 task 的具体代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;%w[start stop restart].each do |command|
  desc &amp;quot;#{command} unicorn server&amp;quot;
  task command do
    on roles(:app, :web) do
      execute &amp;quot;sh #{fetch(:current_path)}/config/unicorn_init.sh #{command}&amp;quot;
    end
  end
end
before :deploy, &amp;quot;unicorn:stop&amp;quot;
after  :deploy, &amp;quot;unicorn:start&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 on roles 指定的是要执行命令具体的服务器，exexcute 是执行具体命令的函数。其中(:current_path)指定的是当前release 代码的路径。因为每次使用 cap deploy 命令后，都会产生一个新的 release，然后远端会切换版本到新的 release 目录。before 和 after 是 hook，它指示了每次某一项任务开始前和完成后所做的一些工作。&lt;/p&gt;

&lt;h2 id=&#34;capistrano-2-与-capistrano-3&#34;&gt;Capistrano 2 与 Capistrano 3&lt;/h2&gt;

&lt;p&gt;Capistrano 2 与 Capistrano 3 差别非常大，一些配置项完全是需要重写的。现在从网上的资料和 github 的 issue 来看 2 比 3 要多很多。可参考的教程2比3也要多出很多，我在使用的是Capistrano 3，在部署时遇到不少的问题。因此如果没有太高的要求，建议继续使用2。以下是我在部署的过程中碰到的一些差异。&lt;/p&gt;

&lt;p&gt;Capistrano 2 可以使用 sudo 执行命令，Capistrano 3 却不行。据他们自己说是为了安全考量。
Capistrano 3 的 task 必须要指定具体的 roles。
Capistrano 2 可以直接调用 set 设置的属性，而 Capistrano 必须使用 fetch 函数去获取。
Capistrano 3 去掉了 current_path, shared_path 等一些公有变量，据说是为了防止部署失败而设计的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>我认为PHP不好的地方</title>
      <link>http://www.leyafo.com/post/2014-05-22-i-think-php-is-terrible/</link>
      <pubDate>Thu, 22 May 2014 00:29:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2014-05-22-i-think-php-is-terrible/</guid>
      <description>

&lt;p&gt;最近在用PHP做项目，让我个人感觉PHP是门非常不顺手的编程语言。PHP太多东西给人的感觉就像是一个半成品。&lt;/p&gt;

&lt;h2 id=&#34;namespace&#34;&gt;namespace&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;PHP&lt;/em&gt; 的 &lt;strong&gt;namespace&lt;/strong&gt; 是我见过的所有语言最难用的 &lt;strong&gt;namespace&lt;/strong&gt;，没有之一。它使用反斜杠&lt;strong&gt;\**来进行层级切分，在使用上非常容易跟 &lt;em&gt;include&lt;/em&gt; 使用的文件路径斜杠搞混淆。&lt;/strong&gt;namespace** 的 &lt;strong&gt;use&lt;/strong&gt; 语句使用也是让人赶到非常奇怪，它不能在代码中的任意作用域使用，只能在一个文件的最顶级作用域中使用 &lt;strong&gt;use&lt;/strong&gt;。&lt;strong&gt;namespace&lt;/strong&gt; 这个东西是控制访问冲突使用的，在文件顶级作用域中使用 &lt;strong&gt;namespace&lt;/strong&gt; 是一个产生冲突的隐患。这就是一个半成品，&lt;em&gt;PHP&lt;/em&gt; 中的内部库函数是没有使用 &lt;em&gt;namespace&lt;/em&gt; 的，也不知道他们自己为啥不用这玩意。&lt;/p&gt;

&lt;h2 id=&#34;变量&#34;&gt;变量&lt;/h2&gt;

&lt;p&gt;在每一个变量前加一个&lt;strong&gt;$&lt;/strong&gt;符号，让我对这个语言的第一印象非常不好，给我的感觉是丑陋。变量名加&lt;strong&gt;$&lt;/strong&gt;可以很方便的嵌入到字符串中，但是 &lt;em&gt;PHP&lt;/em&gt; 在字符串内嵌中增加了 &lt;strong&gt;{}&lt;/strong&gt; 语法，这让变量前面 &lt;strong&gt;$&lt;/strong&gt; 符号失去了它唯一的作用。&lt;strong&gt;$&lt;/strong&gt; 符号除了让代码变得更丑陋以外，没有任何的实际用处。另外在 &lt;em&gt;PHP&lt;/em&gt; 中 &lt;strong&gt;if&lt;/strong&gt; 和 &lt;strong&gt;for&lt;/strong&gt; 还有 &lt;strong&gt;while&lt;/strong&gt; 一系列控制语句中，变量是没有作用域的。可以很随意的去拿 &lt;strong&gt;if&lt;/strong&gt; 和 &lt;strong&gt;else&lt;/strong&gt; 中的变量，解释器不会报错。但是你不知道什么时候解释器会给你报一个 &lt;strong&gt;undefine&lt;/strong&gt; 的错误。&lt;/p&gt;

&lt;h2 id=&#34;函数与闭包&#34;&gt;函数与闭包&lt;/h2&gt;

&lt;p&gt;函数本身没啥好说的，每个语言最基本的单元。如果这玩意也实现不好那真的太糟了。但我要说的是 &lt;em&gt;PHP&lt;/em&gt; 从5.3以后引入的匿名函数。&lt;em&gt;PHP&lt;/em&gt; 的匿名函数看起来好像是可以在任意的地方定义它，这很符合匿名函数的特性。但问题是你如果要用到上下文变量需要显示的使用 &lt;em&gt;use&lt;/em&gt; 将变量引入。这看起来好像是没有什么问题，但是如果函数嵌套的层级一多，这完全是个枷锁。另外如果要判断一个变量是不是一个函数 &lt;em&gt;PHP&lt;/em&gt; 有一个 &lt;strong&gt;is_callable&lt;/strong&gt; 的方法,这个方法的奇怪之处在于你可以传入变量名或者以字符串形式传入函数名。但如果直接传入一个函数它返回的值是 &lt;strong&gt;false&lt;/strong&gt;。经过使用 &lt;strong&gt;is_callable&lt;/strong&gt; 函数的一些失败尝试后，我彻底放弃了 &lt;strong&gt;PHP&lt;/strong&gt; 的匿名函数与闭包。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>avl 树的实现</title>
      <link>http://www.leyafo.com/post/2014-02-09-avl-tree-implementation/</link>
      <pubDate>Sun, 09 Feb 2014 07:01:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2014-02-09-avl-tree-implementation/</guid>
      <description>&lt;p&gt;过年在家没事，找出了几年前把我折磨得死去活来的&lt;a href=&#34;http://book.douban.com/subject/1971825/&#34;&gt;&amp;lt;数据结构与算法分析&amp;gt;&lt;/a&gt;这本书。确切的说，这段时间这本书也在折磨我。上面的avl树的旋转说得不清不楚的，而且还是使用递归实现了avl树的插入与删除操作。让这本书上本身就已经不太清晰的描述变得更加的扑朔迷离，让我有一种想烧掉这本书的冲动。到最后我实在没法看懂书上描述的avl树的操作方式只好自己从网上找一些资料实现了avl树(&lt;a href=&#34;https://github.com/leyafo/practice-algorithm/blob/master/DataStruct/avl_tree.c&#34;&gt;代码在此&lt;/a&gt;)。另外&lt;a href=&#34;http://zh.wikipedia.org/wiki/AVL%E6%A0%91&#34;&gt;维基百科&lt;/a&gt;上有关于avl树基本性质的描述，我在这里也不过多介绍。但是请勿对照这篇文章去实现avl树，这篇描述的删除操作是有问题的。关于树的旋转，这篇文章也没有把最根本的问题说清楚。avl树最难的部分就是关于树的旋转，本文主要讨旋转的问题。&lt;/p&gt;

&lt;p&gt;首先，旋转的作用是降低子树的高度。旋转的方式有两种，一种是用来降低左子树高度一般被称作右旋。一种是用来降低右子树高度一般被称为左旋。这两种旋转在物理上是对称的，在编码上也是无脑对称的。因此，在编码方面我们只需要实现出一种旋转后另一种旋转也可以依葫芦画瓢的实现出来。另外在每个节点中保存一个父节点可以让编码的复杂度大大降低。&lt;/p&gt;

&lt;p&gt;下面是左旋的具体变化过程:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;      A                            B  
       \                          / \  
        B         左旋 ==&amp;gt;        A   C   
         \    
          C   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是右旋的具体变化过程:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;          A                      B   
         /                      / \    
        B         右旋 ==&amp;gt;      C   A    
       /                            
      C   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的这两种情况是比较理想的情况，在实际的使用情况下是没有这么理想的。不能处理下面这些情况。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;                 A                          A
                  \                        /
                   B                      B
                  /                        \
                 C                          C
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的这两种情况就是书上所说的关于双旋转的问题。解决这两种情况的方法就是先旋转B节点,先将C点与B点旋转到A点与B点相同的指向方向。然后在根据A点做对应方向的旋转。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;     A                A                C            A              A               C
      \                \              / \          /                \             / \
       B      =&amp;gt;        C       =&amp;gt;   A   B        B       =&amp;gt;         C      =&amp;gt;   A   B
      /                  \                         \                  \
     C                    B                         C                  B
     
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写到这里貌似可以去开工写代码了，但是请等等。在实际的编码中碰到如下情况还是不知道到底该怎样旋转。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;        A                                  A           
         \                                /
          B                              B
         / \                            / \
        C   D                          C   D
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这两种情况中一般书上给的答案是‘判断新插入的节点到底是在左子树，还是在右子树’。然后再做对应的调整，这样确实是能解决问题的。但是在删除一个节点时，是不可能使用这种方法进行判断的。但我们可以根据树旋转的性质去解决这个问题。从上面的问题可以看出，树旋转最根本的原因就是降低树的高度。根据这个性质我们可以做进一步的分析。对不平衡的子节点去做旋转。那就是&amp;rdquo;哪边更高我们就去将它旋转一下，将它将降低一层&amp;rdquo;。 如果子节点两边的高度是一样的，或者更高的子节点方向与父节点一致的，那么就直接去旋转父节点。
   以上就是avl树基本的旋转过程，avl树和二叉树的插入与删除操作都是一样的。不同的是avl树在插入和删除后需要由下至上扫描并旋转整棵树以保持平衡。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>我认为12306 可以改进的地方</title>
      <link>http://www.leyafo.com/post/2014-01-07-i-think-12306-areas-for-improvement/</link>
      <pubDate>Tue, 07 Jan 2014 10:10:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2014-01-07-i-think-12306-areas-for-improvement/</guid>
      <description>

&lt;h2 id=&#34;几条社会数据&#34;&gt;几条社会数据：&lt;/h2&gt;

&lt;p&gt;2013年春运期间卖出&lt;a href=&#34;http://www.sh.xinhuanet.com/2013-03/08/c_132218725.htm&#34;&gt;2.4亿&lt;/a&gt;张火车票，折半的话单趟就是1.2亿。
这1.2亿张火车票 &lt;a href=&#34;http://www.022net.com/2013/1-23/496633332230569.html&#34;&gt;网络售票数量不到4成&lt;/a&gt;
流动人口总数是2.2亿&lt;a href=&#34;http://money.163.com/11/0428/10/72NJ1E9I00253B0H.html&#34;&gt;(不包括市辖区内人户分离)&lt;/a&gt;。
12306日每天2000万人访问&lt;a href=&#34;http://www.ctocio.com.cn/cloud/120/12820120.shtml&#34;&gt;点击量&lt;/a&gt; 高达14亿
&lt;a href=&#34;http://s.weibo.com/weibo/12306%2520%25E6%259C%2580%25E9%25AB%2598%25E6%2597%25A5%25E5%2594%25AE%25E7%25A5%25A8?topnav=1&amp;amp;wvr=5&amp;amp;b=1&#34;&gt;最高日售票460万张&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以上数据可以得出以下结论：
1.火车的运载量是不太够的。
2.实际网络买票人数员远大于12306售票数的总数。
3.12306卖出的票还是少了点。
下面是我认为12306可以改进的地方。&lt;br /&gt;
##网页前端可以改进的地方：
我这几天也经历过几次买票，在高峰期进入网站后基本上是一个卡住不动的状态了。经过仔细观察12306的前端我发现改进的余地还是非常大的。&lt;/p&gt;

&lt;h3 id=&#34;尽量静态化&#34;&gt;尽量静态化：&lt;/h3&gt;

&lt;p&gt;这么高访问量的网站必须要尽可能的减少客户端请求，网页前端能静态就静态。少设置一点图片，js与css可以参考rails的AssetsPipline 把所有的资源打包成一个文件，去掉不必要图片。这里可以参考&lt;a href=&#34;http://www.ruanyifeng.com/blog/2012/12/obama_fundraising_website.html&#34;&gt;奥巴马的选举网站&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;页面功能单一化&#34;&gt;页面功能单一化&lt;/h3&gt;

&lt;p&gt;访问量这么高，完全可以把网站所有不同功能的页面分开。订票与查询完全可以分开成两个页面，订票页面就不要再有其他的资源链接或者其它功能。&lt;/p&gt;

&lt;h3 id=&#34;订票过程尽量简单&#34;&gt;订票过程尽量简单&lt;/h3&gt;

&lt;p&gt;现在用户订票需要选择日期后再查询，然后服务器再返回好几趟车的数据。我认为这一步实在是很多余，买票的人这么多，大家都会事先查好需要买哪趟车，不会等到出票时间去查询再买。面对这种情况，最好是让用户直接再事前输入准确的车次，起终点站就可以了。这样就能减少服务器与客户端之间的数据传输次数与数据量。&lt;/p&gt;

&lt;h3 id=&#34;可增加的功能-没错-我认为应该增加一些功能&#34;&gt;可增加的功能（没错，我认为应该增加一些功能。）&lt;/h3&gt;

&lt;p&gt;现在的订票助手已经做到了离线化订票，既然这样12306为什么不直接把这件事给干了呢？12306拿到用户的订票信息，可根据偏远程度与火车的运载量在后台进行订票的优先级排序。甚至可以在某辆车运载量不够的情况下为用户自动安排最优化的换乘方案与对应的车票。&lt;/p&gt;

&lt;h3 id=&#34;增加电话订票的可用度&#34;&gt;增加电话订票的可用度&lt;/h3&gt;

&lt;p&gt;不得不说电话订票实在太难用了，中间经历的过程非常烦琐。能用电话订到票的基本上需要一部带有机械键盘的座机与职业游戏玩家的反应与手速才能做到。简化电话订票中间的流程，多开通几个订票号码，这样能分流一部分订票压力。&lt;/p&gt;

&lt;p&gt;##后台改进
从春运的卖出的2.4亿张火车票的数量上来看，这真的是实实在在的大数据处理。甚至被称为世界级难题我认为都是可以的。因为后台跟12306前端所面对的问题完全是不再一个层面上的。因为后台需要将电话，售票点，代售点，网络售票，退票这几个点的火车票全部进行管理。也就是需要为这2.4亿张火车票做一个中心数据库系统。而且这个系统需要满足：
&lt;strong&gt;高并发：&lt;/strong&gt;几百万人在一个时间点同时买票。
&lt;strong&gt;高可用性：&lt;/strong&gt;不能done机
&lt;strong&gt;高响应：&lt;/strong&gt;读写的时间不能太长
&lt;strong&gt;恐怖的一致性：&lt;/strong&gt;是的，这个一致性很恐怖。因为所有的订票请求，都需要在一个地方去拿，不能出现两个人订到了同一张票的情况。虽然电话，售票点，代售点，退票这几个点可以提前分配好资源。网络售票在一个时间点保持几百万个资源的一致性是非常恐怖的操作。&lt;/p&gt;

&lt;p&gt;###改进方案：
&lt;a href=&#34;http://coolshell.cn/articles/6470.html&#34;&gt;陈皓&lt;/a&gt;在去年提出了几点解决方案：&lt;strong&gt;数据镜像 ，数据分区 ，后端系统负载均衡&lt;/strong&gt;&lt;br /&gt;
他的大致思路是一个数据负载均衡的思路。就是尽量不让用户去大量的访问一个点。实际上铁道部已经在去年开始就使用了分时间段买票的方法。这一方法就是一个负载均衡的思路。效果是有了，但是实际上只是消化了一部分数据，但还是有海量的数据存在。我倒是比较赞同他的另外一个思路，就是收集用户的订单，然后到了一定的时间与数量再提交到中数据库中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我的思路：&lt;/strong&gt;
  既然要批量提交，为什么不把剩余票源提前从数据库里面挖出来做一个缓存，然后读写这块缓存，到最后在提交这块缓存到中心数据库。每个节点服务一批用户，缓存的节点不能太少，缓存应该在从中心数据里挖出来的那时候起就要保证将来数据库里一致性的问题。但难度在于如何将用户分配到适合的票源缓存点去？这就要按车次与席别还有乘车日期类型的不同来分配车票的类型。这个计算过程是独立，完全可以很轻松的做到并行计算。&lt;/p&gt;

&lt;p&gt;##小结
春运火车票这个问题基本上无解，因为 需要买票的人数 〉 票的总数。火车的载量也只有那么大，技术能解决的问题只能是让尽可能多人的人更顺利的买的票，不能产生更多的票。所以我想无论是叫阿里还是其他市场化的公司来做这个系统，没有买到票的人该骂的还是照样会骂。当然，上面的提出的一些方式也是比较理想化的。并没有过多的去考虑太多的细节问题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rails 的 AJAX</title>
      <link>http://www.leyafo.com/post/2014-01-06-rails-ajax/</link>
      <pubDate>Mon, 06 Jan 2014 14:00:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2014-01-06-rails-ajax/</guid>
      <description>&lt;p&gt;在 &lt;em&gt;Rails&lt;/em&gt; 中只需要指定在 &lt;em&gt;erb&lt;/em&gt; 模板中指定 &lt;em&gt;remote=true&lt;/em&gt; 选项就可以将请求变为异步的了。&lt;strong&gt;request-handle-response-callback&lt;/strong&gt; 这是一个 &lt;em&gt;AJAX&lt;/em&gt; 请求的过程。&lt;em&gt;rails&lt;/em&gt; 将这些步骤直接简化成了 &lt;em&gt;request&lt;/em&gt; 和 &lt;em&gt;handle&lt;/em&gt; 两步，让它看起来的像魔法一样而简洁神秘。在我初次接触 &lt;em&gt;Rails&lt;/em&gt; 的 &lt;em&gt;AJAX&lt;/em&gt; 时，我也随手去翻了下 &lt;em&gt;wikipedia&lt;/em&gt; 关于 &lt;em&gt;AJAX&lt;/em&gt; 的条目。&lt;em&gt;AJAX&lt;/em&gt; 很好理解，但这并未让我更好的去完全理解 &lt;em&gt;Rails&lt;/em&gt; 魔法般的 *AJAX*。主要被困惑的在 &lt;em&gt;controller&lt;/em&gt; 的 &lt;em&gt;handle&lt;/em&gt; 函数里面的 &lt;em&gt;response&lt;/em&gt; 实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;        def handle
        @model = new some_model
              
        #do something
        
                if @model.save
            respond_to do |format|
                format.js
            end
        end  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是一个典型的 &lt;em&gt;Rails&lt;/em&gt; 应用场景，完全没有了那些简单粗暴原生的 &lt;em&gt;html&lt;/em&gt; 与 &lt;em&gt;javascript&lt;/em&gt; 的代码，更加别想看到 &lt;strong&gt;XMLHttpRequest&lt;/strong&gt; 这种对象了。&lt;em&gt;respond_to&lt;/em&gt; 是一个接收代码块的方法。而 &lt;em&gt;format&lt;/em&gt; 表示 &lt;em&gt;response&lt;/em&gt; 时使用的数据格式，&lt;em&gt;format.js&lt;/em&gt; 会找到对应的 &lt;em&gt;handle.js&lt;/em&gt; 并将里面的 &lt;em&gt;js&lt;/em&gt; 代码 &lt;em&gt;repond&lt;/em&gt; 到客户端。这仅仅只是客户端需要 &lt;em&gt;js&lt;/em&gt; 类型回复的一个需求。如果客户端需要 &lt;em&gt;json，XML，HTML&lt;/em&gt; 等不同类型的数据，只需要在 &lt;em&gt;repondto&lt;/em&gt; 这个代码块使用 &lt;em&gt;format&lt;/em&gt; 对象调用对应的方法即可。&lt;em&gt;rails&lt;/em&gt; 会自动判断并回应对应的类型的数据到前台页面。
  这样做的好处有：
  1.&lt;em&gt;DRY&lt;/em&gt; 原则，不需要根据不同请求类型去定义对应的 &lt;em&gt;response&lt;/em&gt; 方法。
  2.避免因为 &lt;em&gt;request&lt;/em&gt; 与 &lt;em&gt;response&lt;/em&gt; 的数据类型不同而产生错误。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>vim 最佳实践</title>
      <link>http://www.leyafo.com/post/2013-11-26-the-best-practical-vim/</link>
      <pubDate>Tue, 26 Nov 2013 04:01:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2013-11-26-the-best-practical-vim/</guid>
      <description>&lt;p&gt;#重装你的vim
是的,重新安装你的 &lt;em&gt;vim&lt;/em&gt;. 因为默认安装的 &lt;em&gt;vim&lt;/em&gt; 是不带 &lt;em&gt;python&lt;/em&gt; 和 &lt;em&gt;lua,ruby,perl&lt;/em&gt; 这一系列脚本支持的.因此你需要加入这些脚本支持,然后重新编译安装.重新安装前请先备份好 &lt;em&gt;~/.vim&lt;/em&gt; 目录中的东西与 &lt;em&gt;vimrc&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;##源码编译安装:
以 &lt;em&gt;OSX&lt;/em&gt; 系统为例,在 &lt;em&gt;vim&lt;/em&gt; 源码目录的 &lt;em&gt;src&lt;/em&gt; 目录下有一个 &lt;em&gt;configure&lt;/em&gt; 文件.运行 &lt;em&gt;./configure &amp;ndash;help&lt;/em&gt; 可以看到一些编译选项,从中添加你想要的编译选项.在添加 &lt;em&gt;&amp;ndash;enable-pythoninterp&lt;/em&gt; 请一定要带上 &lt;em&gt;&amp;ndash;with-python-config-dir&lt;/em&gt; 这个选项,用来指向你的 &lt;em&gt;python config&lt;/em&gt; 目录.在 &lt;em&gt;OSX&lt;/em&gt; 系统中这个值一般是: &lt;em&gt;/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/config&lt;/em&gt;. 另外请勿使用 &lt;em&gt;homebrew&lt;/em&gt; 安装的 &lt;em&gt;python&lt;/em&gt;, 编译过程中会找不到 &lt;em&gt;python frameworks&lt;/em&gt;. 如果配置有问题可以查看 &lt;em&gt;src&lt;/em&gt; 目录中 &lt;em&gt;auto/config.log&lt;/em&gt; 来看详细错误.编译成功后会在 &lt;em&gt;src/macvim/build/release&lt;/em&gt; 目录生成好 &lt;em&gt;dmg&lt;/em&gt; 安装包.&lt;/p&gt;

&lt;p&gt;##从homebrew中安装:
&lt;em&gt;homebrew&lt;/em&gt; 也是下载好源码然后编译安装的.在 &lt;em&gt;brew install macvim&lt;/em&gt; 前,可以使用 &lt;em&gt;brew edit macvim&lt;/em&gt; 来编辑一些编译选项.只需要在 &lt;em&gt;args = %w[]&lt;/em&gt; 这个中括号里面添加 &lt;em&gt;configure&lt;/em&gt; 中的编译选项. 编译中产生的错误日志可以在 &lt;em&gt;~/Library/Logs/Homebrew/macvim&lt;/em&gt; 目录下查看.&lt;/p&gt;

&lt;p&gt;##重新安装所有的插件
在没有包管理器之前 &lt;em&gt;vim&lt;/em&gt; 的插件是个很不科学的东西.一个插件每次都需要复制 &lt;em&gt;.vim&lt;/em&gt; 插件文件与 &lt;em&gt;doc&lt;/em&gt; 文件到特定的目录中.安装非常麻烦,容易出错.并且 &lt;em&gt;vim&lt;/em&gt; 内部并没有提供后续的插件升级机制.因此后续升级你得自己先去了解插件有没有升级,然后再重新复制文件进行插件安装.这完全是恶心人,因此,用这种方式安装的插件大部分人是不会想着去升级插件的.
还好有了 &lt;a href=&#34;https://github.com/gmarik/vundle&#34;&gt;Vundle&lt;/a&gt; 这么个东西.它是基于 &lt;em&gt;github repositories&lt;/em&gt; 来安装与更新插件的.只需要在 &lt;em&gt;vimrc&lt;/em&gt; 配置好 &lt;em&gt;Bundle&lt;/em&gt; 项就可以搞定插件的安装与更新了.但请注意好 &lt;em&gt;Bundle&lt;/em&gt; 的名字,错了的话就会找不到 &lt;em&gt;github repositories&lt;/em&gt; .另外&lt;a href=&#34;http://vim-scripts.org/vim/scripts.html&#34;&gt;这里&lt;/a&gt;可以搜索到 &lt;em&gt;vim&lt;/em&gt; 几乎所有的插件.
安装完后,将先前备份好的 &lt;em&gt;.vim&lt;/em&gt; 文件夹下的 &lt;em&gt;color&lt;/em&gt; 与 &lt;em&gt;syntax&lt;/em&gt; 复制到新的 &lt;em&gt;.vim&lt;/em&gt; 文件夹中去.因为这两个文件夹下的东西 &lt;em&gt;Bundle&lt;/em&gt; 并未做管理,也不需要管理.&lt;/p&gt;

&lt;p&gt;#你不应该使用的东西
##自动补全
相信我, &lt;em&gt;vim&lt;/em&gt; 只是一个编辑器,自动补全这个玩意很难做到 &lt;em&gt;IDE&lt;/em&gt; 的那种效果.没有自动补全最开始可能会不习惯,写代码速度会慢一点.但习惯了会有很多好处.首先,你的代码命令会非常的规范,不会出现单词与大小写错误的问题.其次不使用自动补全你会对代码理解更好,更深刻.当然,你若要写 &lt;em&gt;Objective-C&lt;/em&gt; 这种的代码,你还是乖乖的用上 &lt;em&gt;IDE&lt;/em&gt; 去自动补全吧.不然这是不人道的.&lt;/p&gt;

&lt;p&gt;##别试图将你的 vim 打造成IDE
网上有很多 &amp;ldquo;将你的 vim 打造成 IDE&amp;rdquo; 一类的文章,别去看这种文章并且跟着他们去安装一些不解决&amp;rsquo;你碰到的问题&amp;rsquo;的插件.既然你都使用编辑器了,就别试图将改装成那种 &lt;em&gt;IDE&lt;/em&gt; 的环境.编辑有编辑器的用法,用得好会比 &lt;em&gt;IDE&lt;/em&gt; 效率更高.&lt;/p&gt;

&lt;p&gt;##不要去使用别人的配置文件
网上有很多公开的 &lt;em&gt;vimrc&lt;/em&gt; 文件,有很多高手的配置文件确实是神乎奇技.但那是别人的配置,别人有别人习惯与癖好.配置文件这个东西还是按你自己个人化的习惯来比较好.尤其是一些配置文件里改了快捷键后,你很难一下子去找到并适应这个快捷键.
另外,也不要去盲目的使用别人推荐的插件.大部分插件是解决特定存在的问题而产生的.你如果安装好一个插件,这个插件你并没有经常拿它去解决&amp;rsquo;你碰到的问题&amp;rsquo;.这个插件迟早有一天会被你遗忘在角落里.而且一些你不经常使用的插件的命令选项会给你造成不必要的记忆负担.&lt;/p&gt;

&lt;p&gt;#一些你应该知道的高级tips
##tag 跳转与缓冲区跳转
&lt;em&gt;vim&lt;/em&gt; 默认是集成了 &lt;em&gt;ctags&lt;/em&gt; 的接口,使用 &lt;em&gt;ctags&lt;/em&gt; 产生 &lt;em&gt;tag&lt;/em&gt; 文件后. &lt;strong&gt;ctrl+[&lt;/strong&gt; 可跳转到函数的定义与声明.使用 &lt;strong&gt;ctrl+o&lt;/strong&gt; 可以跳回上一个缓冲区, &lt;strong&gt;ctrl+i&lt;/strong&gt; 可以跳到下一个缓冲区.这三个快捷键基本上可以满足你到处跳来跳去了.
&lt;!------ mark功能不能在文件之间跳转
##mark
上面的跳转实际上功能比较弱,属于盲跳. *vim* 自带的 *mark* 可以让你有目的性的跳转.在命令模式下,使用 **m**再加一个命名的字母标记就增加了一个类似书签的东西.添加好后,可以是用 **&#39;(单引号)**加上你个刚刚命令的标记就可以跳到指定的地方去了,并且这种跳转还可以跨文件的.比如:使用 **ma** 添加一个标记, 然后使用 **&#39;a** 就可以跳到刚才的那个标记.另外使用命令 **:marks** 可以看到你设置的标记.其中 *0~9* 是最近编辑的文件.
---&gt;
##register
&lt;em&gt;vim&lt;/em&gt; 的 &lt;em&gt;register&lt;/em&gt; 功能类似于 &lt;em&gt;mark&lt;/em&gt; 但他记录了你最近删除与复制的文字.你可以将一段文字复制到特定 &lt;em&gt;register&lt;/em&gt; 中去.然后再从 &lt;em&gt;register&lt;/em&gt; 中复制出来.
使用 &lt;em&gt;visual&lt;/em&gt; 模式选择好一段文字,在命令模式下使用 &lt;strong&gt;&amp;ldquo;ay&lt;/strong&gt; 便将这段文字复制到了名字为 &lt;strong&gt;a&lt;/strong&gt; 的 &lt;em&gt;register&lt;/em&gt; 中.需要使用 &lt;strong&gt;a&lt;/strong&gt; 中的文字,来使用 &lt;strong&gt;&amp;ldquo;ap&lt;/strong&gt; 命令即可.使用 &lt;strong&gt;:reg&lt;/strong&gt; 命令可以看到所有的 &lt;em&gt;register&lt;/em&gt;, 其中 &lt;em&gt;0~9&lt;/em&gt; 显示了最近删除与复制的一些文字.&lt;/p&gt;

&lt;p&gt;##macro
&lt;em&gt;vim&lt;/em&gt; 的 &lt;em&gt;macro&lt;/em&gt; 是用来录制一段动作,然后保存到命名的 &lt;em&gt;macro&lt;/em&gt; 中去的. 使用方法为:在命令模式下使用 &lt;strong&gt;qa&lt;/strong&gt;命令(&lt;strong&gt;a&lt;/strong&gt;代表 &lt;em&gt;marcro&lt;/em&gt; 名,可以是其他数字与字母).这时候状态栏的左边上会显示 &lt;strong&gt;recording&lt;/strong&gt;, 然后做一些操作,做完后在命令模式下使用 &lt;strong&gt;q&lt;/strong&gt; 命令退出录制.然后就可以使用 &lt;strong&gt;@a&lt;/strong&gt; 将这段 &lt;em&gt;macro&lt;/em&gt; &amp;lsquo;播放&amp;rsquo;出来. 如果需要连续做10次,使用 &lt;strong&gt;10@a&lt;/strong&gt;即可.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>尾递归优化</title>
      <link>http://www.leyafo.com/post/2013-11-23-tail-recursion-optimization/</link>
      <pubDate>Sat, 23 Nov 2013 11:47:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2013-11-23-tail-recursion-optimization/</guid>
      <description>&lt;p&gt;&lt;em&gt;递归是一个奇特的玩意,能简洁的描述复杂的思考.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;一个简单的递归函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fibonacci(n):
    if n &amp;lt;= 1:
        return 1
    return fibonacci(n-1) + fibonacci(n-2) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数实现了一个裴波那契数列.非常简单,代码只有 3 行,但如果跟着函数运行的轨迹走.会发现这个函数背后的调用过程非常的复杂.每次递归都会依赖前面两次计算的结果.随着递归的层级上升,每次都会重新去调用前两次计算产生的结果.为了简化描述,下面是以 fibonacci(5) 模拟递归调用过程.
&lt;img src=&#34;http://user-image.logdown.io/user/4793/blog/4808/post/161697/ACy9LF8WSqK0PWHRVX83_fib.png&#34; alt=&#34;fib.png&#34; /&gt;
可以看到,每次递归都会重复前两次的调用过程.实际上这个递归数列并不需要每次都重复去求前两次的结果.如果用压栈的方法,一遍递归就可以搞定了.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fibonacci(n):
    L = fibonacci.L
    if n &amp;lt;= 2:
        return L[-1]  #get top
    else:
        n2 = L.pop()  
        n1 = L.pop()
        L.append(n2)  #&#39;append&#39; is stack&#39;s push  
        L.append(n1+n2)
    return fibonacci(n-1)
fibonacci.L = [1,1]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码耍了一个小花招.首先先设定好两个初始的计算结果,然后开始递归迭代.与前一版本递归不同的是,前一个递归需要在进入到递归底部后,才开始跳出来计算每一步递归后的结果,直到返回.而后一个递归会在最开始递归进入时就开始计算,进入到递归底部后(也就是 n &amp;lt;= 2)最终的结果就已经计算出来了,直接一层一层返回这个结果就可以了.
为了便于说明下面代码是利用两个变量做中间结果的版本:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fib(n, n1=1, n2=1):
    if n &amp;lt; 2:
        return n1
    return fib(n-1, n2, n1+n2)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟上面那个压栈的方式一样.先设定好两个默认的结果,在递归进入时直接将结果计算出来并保存好.
下面是这个函数的调用过程:
  fib(n = 10, n1 = 1, n2 = 1)
  fib(n = 9, n1 = 1, n2 = 2)
  fib(n = 8, n1 = 2, n2 = 3)
  fib(n = 7, n1 = 3, n2 = 5)
  fib(n = 6, n1 = 5, n2 = 8)
  fib(n = 5, n1 = 8, n2 = 13)
  fib(n = 4, n1 = 13, n2 = 21)
  fib(n = 3, n1 = 21, n2 = 34)
  fib(n = 2, n1 = 34, n2 = 55)
  fib(n = 1, n1 = 55, n2 = 89)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于NoSQL</title>
      <link>http://www.leyafo.com/post/2013-11-14-on-nosql/</link>
      <pubDate>Thu, 14 Nov 2013 09:39:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2013-11-14-on-nosql/</guid>
      <description>

&lt;p&gt;传统关系型数据库,将数据以表结构的方式存储起来.并且所有的数据是基于 &lt;em&gt;ACID&lt;/em&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:ACID&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:ACID&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 原则.这种方式存储数据有很明显的缺点.首先,为了保证一致性,基于 &lt;em&gt;ACID&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:ACID&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:ACID&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/em&gt; 类型的数据库都是使用事物来保持数据的一致性.也就是说同时只能有一个 &lt;em&gt;client&lt;/em&gt; 提交数据.然后,以表结构存储的数据库架构是死的,一个表的列基本上是固定的.如果变化的话会带来很多问题.&lt;br /&gt;
比如:&lt;br /&gt;
1.我有一种数据,这些数据都是一些 &lt;em&gt;Excle&lt;/em&gt; 表格.每个表格的列都不相同.但实际上他们都是一种数据.该如何存储?&lt;br /&gt;
2.一个表有 10 列,我想再加一个字段,但这个字段并不是所有数据都需要的.&lt;br /&gt;
3.问题同上,如果加 20 个字段呢?再新建一个表?新建的表如何与现有的表关联?&lt;/p&gt;

&lt;p&gt;最后关联性数据库还有个不利于分布的弱点,如果数据分布在 &lt;em&gt;N&lt;/em&gt; 台分布式的机器上,数据库该如何管理?&lt;/p&gt;

&lt;p&gt;为了弥补这些缺点, &lt;em&gt;NoSQL&lt;/em&gt; 类数据库诞生了.首先 &lt;em&gt;NoSQL&lt;/em&gt; 类数据库有以下特点:&lt;br /&gt;
&lt;strong&gt;schema-less&lt;/strong&gt;: 数据没有字段的概念,并且数据仓库(关联型数据库的 &lt;em&gt;table&lt;/em&gt; )可以随时变化字段.&lt;br /&gt;
&lt;strong&gt;Strong Consistency&lt;/strong&gt;: 保证数据最终的一致性.&lt;br /&gt;
&lt;strong&gt;High Availability&lt;/strong&gt;: 保证所有请求数据的客户端都能得到一份数据的 &lt;em&gt;copy&lt;/em&gt;.&lt;br /&gt;
&lt;strong&gt;Partition-tolerance&lt;/strong&gt;: 数据可以不限于分布在同一台机器上.&lt;/p&gt;

&lt;p&gt;一般 &lt;em&gt;NoSQL&lt;/em&gt; 类数据库存储数据的模型有 4 种方式:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Key-Value&lt;/strong&gt;: 类似于 &lt;em&gt;json&lt;/em&gt; 的 &lt;em&gt;key-value&lt;/em&gt; 的方式进行数据存储&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BigTable&lt;/strong&gt;:  多维度的 &lt;em&gt;key-value&lt;/em&gt; 结构,并且存储方式是分布式,稀疏的&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:-&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:-&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;,严格排序的. *Google*很多产品都在用,具有高压缩,高性能,易于查询的特点.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Documents&lt;/strong&gt;:
多个 &lt;em&gt;key-value&lt;/em&gt; 结构的数据合为一条数据,每一条数据称为为一个 &lt;em&gt;docment&lt;/em&gt;. 并且每个 &lt;em&gt;docment&lt;/em&gt; 的 &lt;em&gt;key-value&lt;/em&gt; 个数和 &lt;em&gt;key&lt;/em&gt; 都可以不同.并且在搜索时,可以以 &lt;em&gt;value&lt;/em&gt; 做为关键字来搜索.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Graph&lt;/strong&gt;:
以网状方式将数据存储在一个 &lt;em&gt;dataset&lt;/em&gt; 中.适合存储有关联的数据.&lt;/p&gt;

&lt;p&gt;从以上的特性可以看出, &lt;em&gt;NoSQL&lt;/em&gt; 类数据库是一种将数据以 &lt;em&gt;OO(Object Oriented)&lt;/em&gt; 方式存储起来.适合做社交网络的关联分析,尤其是 &lt;em&gt;Graph&lt;/em&gt; 模型的 &lt;em&gt;NoSQL&lt;/em&gt; 类数据库.同时 &lt;em&gt;NoSQL&lt;/em&gt; 类数据库的分布式特点在海量数据和海量并发上有着传统关联型数据库无可比拟的优势.&lt;/p&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/nosql&#34;&gt;NoSQL at wikipedia&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.infoq.com/articles/graph-nosql-neo4j&#34;&gt;Graph Databases, NoSQL and Neo4j&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://en.wikipedia.org/wiki/MongoDB&#34;&gt;MongoDB&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:ACID&#34;&gt;即原子性(&lt;em&gt;atomicity&lt;/em&gt;),一致性(&lt;em&gt;consistency&lt;/em&gt;),持久性(&lt;em&gt;durability&lt;/em&gt;),隔离性(&lt;em&gt;isolation&lt;/em&gt;).
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:ACID&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:ACID&#34;&gt;即原子性(&lt;em&gt;atomicity&lt;/em&gt;),一致性(&lt;em&gt;consistency&lt;/em&gt;),持久性(&lt;em&gt;durability&lt;/em&gt;),隔离性(&lt;em&gt;isolation&lt;/em&gt;).
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:ACID&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:-&#34;&gt;这里的稀疏指的并不是存储方式的稀疏,它指的是(&lt;em&gt;map&lt;/em&gt; 结构中的 &lt;em&gt;key-Value&lt;/em&gt; 可以是多维的.&lt;a href=&#34;http://jimbojw.com/wiki/index.php?title=Understanding_Hbase_and_BigTable&#34;&gt;参考链接&lt;/a&gt; 
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:-&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Python内存管理</title>
      <link>http://www.leyafo.com/post/2013-11-08-python-memory-management/</link>
      <pubDate>Fri, 08 Nov 2013 11:25:00 +0800</pubDate>
      
      <guid>http://www.leyafo.com/post/2013-11-08-python-memory-management/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;本文基于Python2.7.5源码中的obmalloc.c模块&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在 Python 的内部系统中，它的内存管理结构是以金子塔结构呈现的.如下图所示:&lt;br /&gt;
&lt;img src=&#34;http://user-image.logdown.io/user/4793/blog/4808/post/159345/6BJdTezMSYK9GlyKCPpO_QQ20131108-2.png&#34; alt=&#34;QQ20131108-2.png&#34; /&gt;
- 其中-1和-2这两层是跟操作系统来负责的,这里我们略过不表.&lt;br /&gt;
- 第0层就是我们平常在 C 中使用的 malloc, Python 不会直接使用它,而是会在此基础上做一个内存池.
- 第1层是 Python 自己在基于 malloc 的基础上构造的一个内存池.
- 第2和第3层是基于第1层的.每当 Python 内部需要使用内存时,会使用第1层做好的分配器来分配内存.
因此第1层是 Python 内部管理内存的主要地方.&lt;/p&gt;

&lt;h2 id=&#34;作用&#34;&gt;作用&lt;/h2&gt;

&lt;p&gt;在 C 中如果频繁的调用 malloc 与 free 时,是会产生性能问题的.再加上频繁的分配与释放小块的内存会产生内存碎片. Python 在这里主要干的工作有:
1. 如果请求分配的内存在1~256字节之间就使用自己的内存管理系统,否则直接使用 malloc.
2. 这里还是会调用 malloc 分配内存,但每次会分配一块大小为256k的大块内存.
3. 经由内存池登记的内存到最后还是会回收到内存池,并不会调用 C 的 free 释放掉.以便下次使用.&lt;/p&gt;

&lt;h2 id=&#34;内存池结构&#34;&gt;内存池结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://user-image.logdown.io/user/4793/blog/4808/post/159345/3Dm6gO5oSFS9uTPwvPrE_temp.png&#34; alt=&#34;temp.png&#34; /&gt;
如上图所示,整个黑框格子代表内存池(usedpools).每个单元格存放一个双向链表,每个链表的节点是一个大小为4k的内存块.在这个池中,每个单元格负责管理不同的小块内存.为了便于管理,每个单元格管理的内存块总是以8的倍数为单位.以如下代码为例:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;PyObject_Malloc(3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们需要一块大小为3个字节的内存.它将定位到管理大小为8字节的单元格.然后返回大小8字节的内存.在这里 usedpools 有一个令人蛋疼的 ticky. usedpools 在初始化时用了如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#define PTA(x)  ((poolp )((uchar *)&amp;amp;(usedpools[2*(x)]) - 2*sizeof(block *)))
#define PT(x)   PTA(x), PTA(x)
static poolp usedpools[2 * ((NB_SMALL_SIZE_CLASSES + 7) / 8) * 8] = {
    PT(0), PT(1), PT(2), PT(3), PT(4), PT(5), PT(6), PT(7)
    ......
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上面所示使用了两个一组的指针来初始化 usedpools, 每次定位到单元格他使用的是 usedpools[idx+idx] 这样来定位的.我也不知道它为什么会使用这么蛋疼且令人费解的设计,连注释都这样写着:
&amp;gt;It&amp;rsquo;s unclear why the usedpools setup is so convoluted.&lt;/p&gt;

&lt;h2 id=&#34;分配&#34;&gt;分配&lt;/h2&gt;

&lt;p&gt;PyObject_Malloc 函数首先会判断进来申请分配的字节数是否在 1&amp;lt;x&amp;lt;256 bytes 这个范围内.然后再从 usedpools  中的管理对应大小的 pool 拿到一块 block, 每个 pool 的大小是4k.每当使用完 pool 中的最后一个 block 时,它会将这个 pool 从 usedpools 剥离出去.
在调用 malloc 获取内存时,这里做了一层缓存(arenas).每次调用 malloc 会分配一块大小为256k的内存,然后将这块内存分解为一块一块大小为4k的 pool,每当 pool 中 block 用完后,就会重新从 arenas 拿一块 pool 并放入到 usedpools.&lt;br /&gt;
在获取空闲 block 时,这里使用了一个 ticky. pool 中的 freeblock 成员是指向一块空闲的 block. 但这个 freeblock 在空闲时,它里面存了一个地址这个地址指向下一块空闲的 block. 下一块空闲的 block 里同样也存放了一个空闲 block 的地址,以此往下推.直到最后的 block 指向 NULL 为止.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;bp = pool-&amp;gt;freeblock;
if ((pool-&amp;gt;freeblock = *(block **)bp) != NULL) {
    UNLOCK();
    return (void *)bp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上面所示,拿到一块 block 后,直接获取 freeblock 里面存的地址,并指向它.&lt;/p&gt;

&lt;h2 id=&#34;释放&#34;&gt;释放&lt;/h2&gt;

&lt;p&gt;在释放时会判断将要释放的内存是否属于 usedpools 管理.通常情况下它会直接将这块内存放到的 usedpools 对应 pools 中.如果发现这个 pools 中的 block 全部是 free 状态,它将会返到 arenas .如果 arenas 中的所有的 pool 都为 free 状态的话,则会直接调用 C 中的 free 函数将内存归还与操作系统.否则将这块 arenas 链接到 usable_arenas 正确的位置中.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>